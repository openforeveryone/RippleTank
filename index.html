<html>

<head>
<title>Matthew Wellings &mdash; Water Ripple Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="Stats.js"></script>
<!--<script type="text/javascript" src="html2canvas.js"></script>-->

<script id="drop-fs" type="x-shader/x-fragment">
    varying mediump vec2 pos;
    uniform lowp float radius;
    uniform lowp vec2 windowSize;
    uniform lowp vec4 channelMask;
    varying mediump vec2 screenPos;
    void main(void)
    {
	lowp float r = distance(gl_FragCoord.xy, screenPos);
	if( r > radius ) discard;
	gl_FragColor = vec4(0,1,0,1);
	highp float dropheight = cos(r/radius*3.141)/4.0 +.25;
	gl_FragColor = channelMask*dropheight;
    }
</script>

<script id="drop-vs" type="x-shader/x-vertex">
    attribute highp vec4 vertex;
    varying mediump vec2 screenPos;
    uniform lowp float radius;
    uniform lowp vec2 windowSize;
    void main(void)
    {
	gl_PointSize = radius*2.0;
//        gl_PointSize = 80.0;
	// Convert position to window coordinates
	screenPos = (vertex.xy/2.0+vec2(0.5,0.5)) * windowSize.xy;
	gl_Position = vertex;
    }
</script>

<script id="forcecalc-fs" type="x-shader/x-fragment">
    uniform sampler2D waterLevelTex;
    uniform mediump vec2 windowSize;
//     uniform mediump float time;
//     varying mediump vec2 pos;
    varying mediump vec2 v_texcord;
    void main(void)
    {
	  mediump vec2 currentpos = v_texcord; //Componant-wise division.
	  mediump vec2 windowSizeR = vec2(1.0/windowSize.x, 1.0/windowSize.y);
	  mediump vec4 averageNeighbourLevel = (
		    texture2D(waterLevelTex, vec2(currentpos.x-windowSizeR.x, currentpos.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x+windowSizeR.x, currentpos.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x, currentpos.y-windowSizeR.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x, currentpos.y+windowSizeR.y)))/4.0;

	  mediump vec4 leveldiff=averageNeighbourLevel-texture2D(waterLevelTex, currentpos);
	  mediump vec4 k=vec4(1,1,0,1);
	  mediump vec4 force = leveldiff*k; //Hooke's law
      //    gl_FragColor=vec4(0,1,0,1);
	  gl_FragColor = force;   //Integrating on Newton2 dobe by blending.
      //    gl_FragColor = texture2D(waterLevelTex, currentpos);
    }
</script>

<script id="forcecalc-vs" type="x-shader/x-vertex">
      attribute highp vec2 vertex;
      attribute highp vec2 texcord;
//       varying mediump vec2 pos;
      varying mediump vec2 v_texcord;

      void main(void)
      {
// 	  pos = vertex.xy;
	  v_texcord = texcord;
	  gl_Position = vec4(vertex,0,1);
      }
</script>

<script id="integrate-fs" type="x-shader/x-fragment">
      uniform sampler2D waterVelTex;
      varying mediump vec2 v_texcord;

      void main(void)
      {
	  gl_FragColor = texture2D(waterVelTex, v_texcord);
      }
</script>

<script id="integrate-vs" type="x-shader/x-vertex">
      attribute highp vec4 vertex;
      attribute highp vec2 texcord;
      varying mediump vec2 v_texcord;      
      void main(void)
      {	  
	  v_texcord = texcord;
	  gl_Position = vertex;
      }
</script>

<script id="render-fs" type="x-shader/x-fragment">
      uniform sampler2D s_texture;
      varying mediump vec2 v_texcoord;
      uniform mediump vec2 windowSize;
      void main() {
	  highp vec4 colour = texture2D(s_texture, v_texcoord);
	  //In WebGL transparency is not ignored, so discard it now:
// 	  gl_FragColor = vec4(colour.r,0,colour.b,1);
// 	  gl_FragColor = vec4(0, 0,(colour.r*0.8+0.25)+(colour.g*0.2+0.25),  1.0);

	  
	  mediump vec2 currentpos = v_texcoord; //Componant-wise division.
	  mediump vec2 windowSizeR = vec2(1.0/windowSize.x, 1.0/windowSize.y);
	  mediump vec2 diffs = vec2(
		    texture2D(s_texture, vec2(currentpos.x+windowSizeR.x, currentpos.y)).x
		  - texture2D(s_texture, vec2(currentpos.x-windowSizeR.x, currentpos.y)).x,
		    texture2D(s_texture, vec2(currentpos.x, currentpos.y+windowSizeR.y)).x
		  - texture2D(s_texture, vec2(currentpos.x, currentpos.y-windowSizeR.y)).x);
	  mediump vec3 va = vec3(1, 0, diffs.x*2.0);
          mediump vec3 vb = vec3(0, 1, diffs.y*2.0);
          mediump vec3 normalWS = normalize(cross(va,vb));//.rbg; //you may not need to swizzle the normal
          
//           gl_FragColor =  vec4(normalWS.xy,0, 1.0);
          mediump vec4 color = vec4(0,0,0.4,1);
	  mediump float specularity = 50.0;
	  //As we are not rotating the view camera direction is always (0,0,1) and with light in (-1,1,1) halfvec is normalize(1,1,2).
	  mediump vec3 toLightWS = vec3(-1,1,1);
	  mediump vec3 halfVectorWS = normalize(vec3(-1,1,2));
	  mediump float cosLightAngle = max(dot(normalWS, toLightWS), 0.0);
	  mediump float cosSpecAngle = max(dot(normalWS, halfVectorWS), 0.0);      
	  mediump vec4 surfacecolour = color + cosLightAngle * 0.4 + pow(cosSpecAngle, specularity);
	  surfacecolour.r = max(surfacecolour.r, colour.b);
// 	  if (colour.b>.1) discard;
          gl_FragColor = surfacecolour;
      }
</script>

<script id="render-vs" type="x-shader/x-vertex">
    uniform sampler2D s_texture;
    attribute highp vec2 posAttr;
    attribute highp vec2 texcoordAttr;
    varying lowp vec2 v_texcoord;
    uniform highp mat4 matrix;
    void main() {
	v_texcoord=texcoordAttr;
	highp vec4 height = texture2D(s_texture, v_texcoord);
	gl_Position = matrix * vec4(posAttr.xy, height.x*.2, 1);
    }
</script>

<script id="wall-fs" type="x-shader/x-fragment">
      void main(void)
      {
	  gl_FragColor = vec4(0,0,1,0);
      }
</script>

<script id="wall-vs" type="x-shader/x-vertex">
      attribute highp vec4 vertex;   
      void main(void)
      {	  
	  gl_Position = vertex;
      }
</script>

<script type="text/javascript">

    function checkError() {
	var glerror = gl.getError()
	if (glerror!=gl.NO_ERROR)
	{
// 	    console.error("GL Error " + WebGLDebugUtils.glEnumToString(glerror));
	    if (glerror==gl.INVALID_ENUM)
	      glerror="GL_INVALID_ENUM";
	    else if (glerror==gl.INVALID_OPERATION)
	      glerror="GL_INVALID_OPERATION";
	    console.error("GL Error " + glerror);
	}
    }
    
    var gl;
    function initGL(canvas) {
        try {
// 	    gl = WebGLDebugUtils.makeDebugContext(canvas.getContext("experimental-webgl"));
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (gl) {
            return true;
	}else{
	    alert("This page requires WebGL but it cannot be accessed, try upgrading your browser or graphics drivers.");
            return false;
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function getShaderProgram(gl, vertexShader, fragmentShader) {
	var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        return shaderProgram;
    }
    
    var dropShaderProgram;
    var forcecalcShaderProgram;
    var integrateShaderProgram;
    var renderShaderProgram;
    var wallShaderProgram

    function initShaders() {
        var dropFragmentShader = getShader(gl, "drop-fs");
        var dropVertexShader = getShader(gl, "drop-vs");
        var forcecalcFragmentShader = getShader(gl, "forcecalc-fs");
        var forcecalcVertexShader = getShader(gl, "forcecalc-vs");
        var integrateFragmentShader = getShader(gl, "integrate-fs");
        var integrateVertexShader = getShader(gl, "integrate-vs");
        var renderFragmentShader = getShader(gl, "render-fs");
        var renderVertexShader = getShader(gl, "render-vs");
        var wallFragmentShader = getShader(gl, "wall-fs");
        var wallVertexShader = getShader(gl, "wall-vs");

	dropShaderProgram = getShaderProgram(gl, dropFragmentShader, dropVertexShader);
	forcecalcShaderProgram = getShaderProgram(gl, forcecalcFragmentShader, forcecalcVertexShader);
	integrateShaderProgram = getShaderProgram(gl, integrateFragmentShader, integrateVertexShader);
	renderShaderProgram = getShaderProgram(gl, renderFragmentShader, renderVertexShader);
	wallShaderProgram = getShaderProgram(gl, wallFragmentShader, wallVertexShader);

        gl.useProgram(dropShaderProgram);
        dropShaderProgram.vertexAttribute = gl.getAttribLocation(dropShaderProgram, "vertex");
        dropShaderProgram.radiusUniform = gl.getUniformLocation(dropShaderProgram, "radius");
        dropShaderProgram.windowSizeUniform = gl.getUniformLocation(dropShaderProgram, "windowSize");
        dropShaderProgram.channelMaskUniform = gl.getUniformLocation(dropShaderProgram, "channelMask");
                
        gl.useProgram(forcecalcShaderProgram);
        forcecalcShaderProgram.vertexAttribute = gl.getAttribLocation(forcecalcShaderProgram, "vertex");
        forcecalcShaderProgram.texcoordAttribute = gl.getAttribLocation(forcecalcShaderProgram, "texcord");
        forcecalcShaderProgram.windowSizeUniform = gl.getUniformLocation(forcecalcShaderProgram, "windowSize");
        forcecalcShaderProgram.timeUniform = gl.getUniformLocation(forcecalcShaderProgram, "time");
        
        gl.useProgram(integrateShaderProgram);
        integrateShaderProgram.vertexAttribute = gl.getAttribLocation(integrateShaderProgram, "vertex");
        integrateShaderProgram.texcoordAttribute = gl.getAttribLocation(integrateShaderProgram, "texcord");
        
        gl.useProgram(renderShaderProgram);
        renderShaderProgram.vertexAttribute = gl.getAttribLocation(renderShaderProgram, "posAttr");
        renderShaderProgram.texcoordAttribute = gl.getAttribLocation(renderShaderProgram, "texcoordAttr");
        renderShaderProgram.matrixUniform = gl.getUniformLocation(renderShaderProgram, "matrix");     
        renderShaderProgram.windowSizeUniform = gl.getUniformLocation(renderShaderProgram, "windowSize");  
        
        gl.useProgram(wallShaderProgram); 
        wallShaderProgram.vertexAttribute = gl.getAttribLocation(wallShaderProgram, "vertex");
    }
    
    var waterHeightTX;
    var waterHeightFramebuffer;    
    var waterVelTX;
    var waterVelFramebuffer;
    var WaterBufferSize=512;
    var cvTX;
    
    
    function initFrameBuffers() {
	var ext = gl.getExtension('OES_texture_float');
	if (!ext) {
	  alert("This page requires the 'OES_texture_float' extension, try upgrading your browser or graphics drivers.");
	  return false;
	}
	
	checkError();
	waterHeightTX = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);	
	//Need a replacement for this
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_BORDER);
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_BORDER);
// 	var borderColour = [0.5, 0.0, 0.0, 1.0];
// 	gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_BORDER_COLOR, borderColour);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, WaterBufferSize, WaterBufferSize, 0, gl.RGBA, gl.FLOAT, null);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	
	waterHeightFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, waterHeightTX, 0);
	gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);    
	gl.clearColor(0.0, 0.0, 0.0, 1.0);        
        gl.clear(gl.COLOR_BUFFER_BIT);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	  console.error("Framebuffer Error");
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	waterVelTX = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, waterVelTX);	
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, WaterBufferSize, WaterBufferSize, 0, gl.RGBA, gl.FLOAT, null);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	
	waterVelFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, waterVelFramebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, waterVelTX, 0);
	gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);    
	gl.clearColor(0.0, 0.0, 0.0, 1.0);        
        gl.clear(gl.COLOR_BUFFER_BIT);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	  console.error("Framebuffer Error");
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	  console.error("Framebuffer Error");
	checkError();
	return true;
    }
    
    var meshVertices = [];
    var meshTexCoords = [];
    var meshIndices = [];
    
    function buildMesh()
    {        
	var meshSize = 128;
	for (var i=0; i<meshSize; i++)
	{	
	    for (var j=0; j<meshSize; j++)
	    {
		meshVertices.push(i/meshSize*2-1);
		meshVertices.push(j/meshSize*2-1);
		meshTexCoords.push(i/meshSize*0.96+0.02);//Do not show the edges wich do not move
		meshTexCoords.push(j/meshSize*0.96+0.02);
	    }
	}
	for (var i=0; i<meshSize-1; i++)
	{	
	    for (var j=0; j<meshSize-1; j++)
	    {
		meshIndices.push(j+i*meshSize);
		meshIndices.push(j+1+i*meshSize);
		meshIndices.push(j+(i+1)*meshSize);
		
		meshIndices.push(j+1+i*meshSize);
		meshIndices.push(j+(i+1)*meshSize);
		meshIndices.push(j+1+(i+1)*meshSize);
		
	    }
	}
    }
    
    var VertexPositionBuffer;
    var TexCoordPositionBuffer;
    var VertexPositionBufferR;
    var TexCoordPositionBufferR;
    var IndexBufferR;
    var WallPositionBuffer;
    var BarPositionBuffer;
    var DropPositionBuffer;
    
    function initBuffers() {    
      VertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
      var vertices = [
	  -1, 1,
	  -1, -1,
	  1, -1,

	  1, 1,
	  1, -1,
	  -1, 1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      VertexPositionBuffer.itemSize = 2;
      VertexPositionBuffer.numItems = 6;
// 
      TexCoordPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBuffer);
      var texcords = [
	  0, 1,
	  0, 0,
	  1, 0,

	  1, 1,
	  1, 0,
	  0, 1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcords), gl.STATIC_DRAW);
      TexCoordPositionBuffer.itemSize = 2;
      TexCoordPositionBuffer.numItems = 6;
      
      buildMesh();
      VertexPositionBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBufferR);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshVertices), gl.STATIC_DRAW);
      VertexPositionBufferR.itemSize = 2;
      VertexPositionBufferR.numItems = meshVertices.length/VertexPositionBufferR.itemSize;
      TexCoordPositionBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBufferR);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshTexCoords), gl.STATIC_DRAW);
      TexCoordPositionBufferR.itemSize = 2;
      TexCoordPositionBufferR.numItems = meshTexCoords.length/TexCoordPositionBufferR.itemSize;
      IndexBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IndexBufferR);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(meshIndices), gl.STATIC_DRAW);
      IndexBufferR.numItems = meshIndices.length;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      
      WallPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, WallPositionBuffer);
//       var wallvertices = [
// 	  -1, 1,
// 	  -1, -1,
// 	  -1, -1,
// 	  1, -1,
// 	  1, -1,
// 	  1, 1,
// 	  1, 1,
// 	  -1, 1,
//       ];
      
      var a = 1 - 1/256;
      var wallvertices = [
	  -a, a,
	  -a, -a,
	  -a, -a,
	  a, -a,
	  a, -a,
	  a, a,
	  a, a,
	  -a, a,
      ];
      
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(wallvertices), gl.STATIC_DRAW);
      WallPositionBuffer.itemSize = 2;
      WallPositionBuffer.numItems = 8;      
      
      BarPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, BarPositionBuffer);
      var barvertices = [
	  -.025, 1,
	  -.025, .05,
	  .025, .05,

	  .025, 1,
	  .025, .05,
	  -.025, 1,
	  
	  -.025, -1,
	  -.025, -0.05,
	  .025, -.05,

	  .025, -1,
	  .025, -0.05,
	  -.025, -1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(barvertices), gl.STATIC_DRAW);
      BarPositionBuffer.itemSize = 2;
      BarPositionBuffer.numItems = 12;      
      
      DropPositionBuffer = gl.createBuffer();

    }
    
    var mvMatrix;
    var frameNumber=0;
    var newDrops = [];
    var DropSize = 40;
    var rotateAnim = false;
    var rotateProgress = 0;
    var running = true;

    function drawScene() {
// 
// //         mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
// 
        
	gl.disable(gl.DEPTH_TEST);
	gl.disable(gl.CULL_FACE);
        frameNumber++;      
        //Add a new drop 200 frames in:
        if (frameNumber==200)
        {
	  newDrops = [[-0.5,-0.5]];
	}
	//Add the drops that are in the queue to the framebuffer:
        if (newDrops.length)
        {        
	    checkError();
	    console.log("Preparing to add new drops");
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer);
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);
	    gl.useProgram(dropShaderProgram);
	    gl.uniform2f(dropShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	    gl.uniform1f(dropShaderProgram.radiusUniform, DropSize/2.0);
	    if (frameNumber==1)
		gl.uniform4f(dropShaderProgram.channelMaskUniform, 0,1,0,0);
	    else
		gl.uniform4f(dropShaderProgram.channelMaskUniform, 1,0,0,0);
	    //Add drops
	    var posArray = [];
	    for(var drop =0; drop < newDrops.length; drop++)
	    {        
		  console.log("Adding drop " + drop + " " +newDrops[drop][0] + " " + newDrops[drop][1]);
		  posArray[drop*2+0]=newDrops[drop][0];
		  posArray[drop*2+1]=newDrops[drop][1];
	    }	    
	    console.log(posArray.toString());
	    checkError();
	    gl.enableVertexAttribArray(dropShaderProgram.vertexAttribute);
	    gl.bindBuffer(gl.ARRAY_BUFFER, DropPositionBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posArray), gl.DYNAMIC_DRAW);	    
	    gl.vertexAttribPointer(dropShaderProgram.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
	    checkError();
	    gl.drawArrays(gl.POINTS, 0, newDrops.length);
	    checkError();
	    newDrops = [];
        }
        
        if (running)
        {
	    //Calc water velocity:	
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterVelFramebuffer);  
	    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
		console.error("Framebuffer Error");
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);
    //         gl.clearColor(1.0, 1.0, 0.0, 1.0);
    //         gl.clear(gl.COLOR_BUFFER_BIT); 
	    gl.useProgram(forcecalcShaderProgram);
	    gl.enableVertexAttribArray(forcecalcShaderProgram.vertexAttribute);
	    gl.enableVertexAttribArray(forcecalcShaderProgram.texcoordAttribute);
	    gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
	    gl.vertexAttribPointer(forcecalcShaderProgram.vertexAttribute, VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	    gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBuffer);
	    gl.vertexAttribPointer(forcecalcShaderProgram.texcoordAttribute, TexCoordPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	    gl.uniform2f(forcecalcShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	    gl.enable(gl.BLEND);
	    gl.blendEquation(gl.FUNC_ADD);
	    gl.blendFunc(gl.ONE,gl.ONE);
	    gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);
	    checkError();
	    
	    //Integrate water velocity:	
	    gl.bindTexture(gl.TEXTURE_2D, waterVelTX);
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer); 
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize); 
    //         gl.clearColor(1.0, 0.0, 0.0, 1.0);
    //         gl.clear(gl.COLOR_BUFFER_BIT); 
	    gl.useProgram(integrateShaderProgram);
	    gl.enableVertexAttribArray(integrateShaderProgram.vertexAttribute);
	    gl.enableVertexAttribArray(integrateShaderProgram.texcoordAttribute);
	    gl.enable(gl.BLEND);
	    gl.blendColor(0.995,1,1,1);
	    gl.blendEquation(gl.FUNC_ADD);
	    gl.blendFunc(gl.CONSTANT_COLOR,gl.CONSTANT_COLOR);
	    gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);
	}
	
	//Reset areas that are walls:
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.disable(gl.BLEND);	
        gl.useProgram(wallShaderProgram);
	gl.enableVertexAttribArray(wallShaderProgram.vertexAttribute);	
        gl.bindBuffer(gl.ARRAY_BUFFER, WallPositionBuffer);
        gl.vertexAttribPointer(WallPositionBuffer.vertexAttribute, WallPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.LINES, 0, WallPositionBuffer.numItems);
        gl.bindBuffer(gl.ARRAY_BUFFER, BarPositionBuffer);
        gl.vertexAttribPointer(BarPositionBuffer.vertexAttribute, BarPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLES, 0, BarPositionBuffer.numItems);
	
        
        //Render to screen
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);   
	gl.bindTexture(gl.TEXTURE_2D, waterVelTX); 
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
	gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);
    
	mvMatrix = mat4.create();
        
	if (rotateAnim)
	{
	    rotateProgress+=1.0/60.0;
	    if (rotateProgress>=1)
	      rotateAnim=false;
	}
	
	mat4.perspective(mvMatrix, 1, gl.viewportWidth/gl.viewportHeight, 0.1, 5.0);	    
	mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -1.82]);   	    
	if (rotateProgress>0)
	{
	    var rotateProgressNL = (Math.sin((rotateProgress+1.5)*Math.PI)+1)/2;
	    mat4.translate(mvMatrix, mvMatrix, [0,0, -1*rotateProgressNL]);  
	    mat4.rotateX(mvMatrix, mvMatrix, -1*rotateProgressNL);   
	    mat4.rotateZ(mvMatrix, mvMatrix, 3.14/4*rotateProgressNL);	    
// 	    mat4.translate(mvMatrix, mvMatrix, [0,0, .5*rotateProgressNL]);   	
	}
	
        gl.useProgram(renderShaderProgram);
        gl.disableVertexAttribArray(2);
        gl.disableVertexAttribArray(3);
	gl.enableVertexAttribArray(renderShaderProgram.vertexAttribute);
	gl.enableVertexAttribArray(renderShaderProgram.texcoordAttribute);
	
        gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBufferR);
        gl.vertexAttribPointer(renderShaderProgram.vertexAttribute, VertexPositionBufferR.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBufferR);
        gl.vertexAttribPointer(renderShaderProgram.texcoordAttribute, TexCoordPositionBufferR.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IndexBufferR);
        gl.uniformMatrix4fv(renderShaderProgram.matrixUniform, false, mvMatrix);
	gl.uniform2f(renderShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	gl.disable(gl.BLEND);
	gl.drawElements(gl.TRIANGLES, IndexBufferR.numItems, gl.UNSIGNED_SHORT, 0);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	
// 	gl.useProgram(integrateShaderProgram);
// 	gl.bindTexture(gl.TEXTURE_2D, cvTX);
// 	gl.enable(gl.BLEND);
// 	gl.blendFunc (gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
// 	gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);

//         gl.enableVertexAttribArray(dropShaderProgram.vertexAttribute);
//         mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
//         gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
//         setMatrixUniforms();
//         gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
// 
// 
//         mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
//         gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
//         gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
//         setMatrixUniforms();
//         gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
    }
    var stats;
    
    function renderLoop()
    {        
	stats.begin();
	drawScene();
	stats.end();
	requestAnimationFrame( renderLoop );
    }

    
//     function test(canvas1)
//     {    
// 
// 	console.log("test");
//     }
    
    function webGLStart() {
	stats = new Stats();	
	stats.setMode( 0 ); // 0: fps, 1: ms, 2: mb
	// align top-left
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.left = '8px';
	stats.domElement.style.top = '528px';
	document.body.appendChild( stats.domElement );
	
        var canvas = document.getElementById("water-canvas");
//         canvas.width = document.body.clientWidth; //document.width is obsolete
// 	canvas.height = document.body.clientHeight; //document.height is obsolete
// 	canvas.width = window.innerWidth-20;
// 	canvas.height = window.innerHeight-20;
	
	canvas.style.position = 'absolute';
	canvas.style.left = '8px';
	canvas.style.top = '8px';
// 	canvas.style.zIndex = '-1';
    
        var rotateButton = document.getElementById("rotate");
	rotateButton.style.position = 'absolute';
	rotateButton.style.left = '100px';
	rotateButton.style.top = '528px';
	
//         var mainbody = document.getElementById("mainbody");
//         
// 	mainbody.style.position = 'absolute';
// 	mainbody.style.left = '8px';
// 	mainbody.style.top = '8px';
        
	

	
    
        initGL(canvas);
        initShaders();
        initFrameBuffers();
        initBuffers();

// 	html2canvas(mainbody, {
// 	  onrendered: function(canvas1) {
// // 	      document.body.appendChild(canvas1);
// // 	      canvas1.style.position = 'absolute';
// // 	      canvas1.style.left = '18px';
// // 	      canvas1.style.top = '600px';
// 	      
// 	      cvTX = gl.createTexture();
// 	      gl.bindTexture(gl.TEXTURE_2D, cvTX);	
// 	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas1);
// 	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
// 	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
// 	  },
// 	  width: 512,
// 	  height: 512	  
// 	});
	
// 	mainbody.style.display = 'none';
// 	mainbody.remove();
        gl.enable(gl.DEPTH_TEST);
        
        canvas.addEventListener('mousedown', function(event) {        
// 	    alert("Clicked " + x + " " + y);	
	    switch (event.which) {
	    case 1:
		var x = event.pageX - canvas.offsetLeft,
		    y = event.pageY - canvas.offsetTop;	
    // 	    x = (x / 2.0 + 0.5) * WaterBufferSize;
		x = (x / canvas.clientWidth - 0.5) * 2;
		y = -(y / canvas.clientWidth - 0.5) * 2;
		
		drop = [x,y];
		var invmat = mat4.create();
		mat4.invert(invmat, mvMatrix);
		var depth=1;
		var z=-.9;
		while (depth>.0)
		{
		    z=z+.0005;
		    var point = vec4.fromValues(x,y,z,1);
// 		    console.log("point " + point[0] + " " + point[1]+ " " + point[2]+ " " + point[3]);
		    vec4.transformMat4(point, point, invmat);
    // 		console.log("point " + point[0] + " " + point[1]+ " " + point[2]+ " " + point[3]);
// 		    console.log("point " + point[0]/point[3] + " " + point[1]/point[3]+ " " + point[2]/point[3]);
		    depth=point[2]/point[3];
		}
		
		drop = [point[0]/point[3],point[1]/point[3]];
		newDrops.push(drop);    
            break;            
	    case 3:
		rotateAnim=true;
	    }
        });
        
        
        for (var i = 0; i < 20; i++)
        {
	    x = (Math.random() - 0.5) * 2;
	    y = -(Math.random() - 0.5) * 2;
	    drop = [x,y];
	    newDrops.push(drop);
        }

	requestAnimationFrame( renderLoop );
    }	   
</script>
</head>
<body onload="webGLStart();">
    <!--<div id="mainbody">
	<h1>Matthew Wellings</h1>
	<p id ="subtitle">Software Developer</p>
	<p>
	Specialising in:<br>
	Qt (For Desktop, Embedded and Server)<br> 
	Android (Java and NDK C++)<br>
	OpenGL (Modern Desktop + ES)<br>
	LAMP software
	</p>

	<h2>Contact</h2>
	<p>
	I can be contacted:<br>
	by email <a href="mailto:website@matthewwellings.com">website@matthewwellings.com</a><br>
	on <a href="https://Google.com/+MatthewWellings">GooglePlus</a><br>
	on <a href="https://www.facebook.com/matt.wellings.90">Facebook</a><br>
	on <a href="tel:+441212888633">+44(0)1212888633</a><br>
	on <a href="skype:openforeveryone">Skype</a>

	<h2>Public Projects</h2>
	<h3>OSS</h3>
	<p>
	<a href="http://wordsearchcreator.org/">Word Search Creator</a><br>
	Other OSS code on <a href="https://github.com/openforeveryone/">my Github page</a>.<br>
	</p>

	<h2>CV</h2>
	For my full CV please contact me.
    </div>-->
    <canvas id="water-canvas" style="border: none;" width="512" height="512"></canvas>    
    <button id = "rotate" type="button" onclick="rotateAnim=true;">Rotate</button> 
</body>
</html>
