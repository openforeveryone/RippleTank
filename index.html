<html>

<head>
<title>Matthew Wellings &mdash; Water Ripple Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="Stats.js"></script>
<!--<script type="text/javascript" src="html2canvas.js"></script>-->

<script id="drop-fs" type="x-shader/x-fragment">
    varying mediump vec2 pos;
    uniform lowp float radius;
    uniform lowp vec2 windowSize;
    uniform lowp vec4 channelMask;
    varying mediump vec2 screenPos;
    void main(void)
    {
	lowp float r = distance(gl_FragCoord.xy, screenPos);
	if( r > radius ) discard;
	gl_FragColor = vec4(0,1,0,1);
	highp float dropheight = cos(r/radius*3.141)/4.0 +.25;
	gl_FragColor = channelMask*dropheight;
    }
</script>

<script id="drop-vs" type="x-shader/x-vertex">
    attribute highp vec4 vertex;
    varying mediump vec2 screenPos;
    uniform lowp float radius;
    uniform lowp vec2 windowSize;
    void main(void)
    {
	gl_PointSize = radius*2.0;
//        gl_PointSize = 80.0;
	// Convert position to window coordinates
	screenPos = (vertex.xy/2.0+vec2(0.5,0.5)) * windowSize.xy;
	gl_Position = vertex;
    }
</script>

<script id="forcecalc-fs" type="x-shader/x-fragment">
    uniform sampler2D waterLevelTex;
    uniform mediump vec2 windowSize;
//     uniform mediump float time;
//     varying mediump vec2 pos;
    varying mediump vec2 v_texcord;
    void main(void)
    {
	  mediump vec2 currentpos = v_texcord; //Componant-wise division.
	  mediump vec2 windowSizeR = vec2(1.0/windowSize.x, 1.0/windowSize.y);
	  mediump vec4 averageNeighbourLevel = (
		    texture2D(waterLevelTex, vec2(currentpos.x-windowSizeR.x, currentpos.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x+windowSizeR.x, currentpos.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x, currentpos.y-windowSizeR.y))
		  + texture2D(waterLevelTex, vec2(currentpos.x, currentpos.y+windowSizeR.y)))/4.0;

	  mediump vec4 leveldiff=averageNeighbourLevel-texture2D(waterLevelTex, currentpos);
	  mediump vec4 k=vec4(1,1,0,1);
	  mediump vec4 force = leveldiff*k; //Hooke's law
      //    gl_FragColor=vec4(0,1,0,1);
	  gl_FragColor = force;   //Integrating on Newton2 dobe by blending.
      //    gl_FragColor = texture2D(waterLevelTex, currentpos);
    }
</script>

<script id="forcecalc-vs" type="x-shader/x-vertex">
      attribute highp vec2 vertex;
      attribute highp vec2 texcord;
//       varying mediump vec2 pos;
      varying mediump vec2 v_texcord;

      void main(void)
      {
// 	  pos = vertex.xy;
	  v_texcord = texcord;
	  gl_Position = vec4(vertex,0,1);
      }
</script>

<script id="integrate-fs" type="x-shader/x-fragment">
      uniform sampler2D waterVelTex;
      varying mediump vec2 v_texcord;

      void main(void)
      {
	  gl_FragColor = texture2D(waterVelTex, v_texcord);
      }
</script>

<script id="integrate-vs" type="x-shader/x-vertex">
      attribute highp vec4 vertex;
      attribute highp vec2 texcord;
      varying mediump vec2 v_texcord;      
      void main(void)
      {	  
	  v_texcord = texcord;
	  gl_Position = vertex;
      }
</script>

<script id="render-fs" type="x-shader/x-fragment">
      uniform sampler2D s_texture;
      varying mediump vec2 v_texcoord;
      uniform mediump vec2 windowSize;
      uniform highp mat3 mmatrix;
      void main() {
	  highp vec4 colour = texture2D(s_texture, v_texcoord);
	  //In WebGL transparency is not ignored, so discard it now:
// 	  gl_FragColor = vec4(colour.r,0,colour.b,1);
// 	  gl_FragColor = vec4(0, 0,(colour.r*0.8+0.25)+(colour.g*0.2+0.25),  1.0);

	  
	  mediump vec2 currentpos = v_texcoord; //Componant-wise division.
	  mediump vec2 windowSizeR = vec2(1.0/windowSize.x, 1.0/windowSize.y);
	  mediump vec2 diffs = vec2(
		    texture2D(s_texture, vec2(currentpos.x+windowSizeR.x, currentpos.y)).x
		  - texture2D(s_texture, vec2(currentpos.x-windowSizeR.x, currentpos.y)).x,
		    texture2D(s_texture, vec2(currentpos.x, currentpos.y+windowSizeR.y)).x
		  - texture2D(s_texture, vec2(currentpos.x, currentpos.y-windowSizeR.y)).x);
	  mediump vec3 va = vec3(1, 0, diffs.x*2.0);
          mediump vec3 vb = vec3(0, 1, diffs.y*2.0);
          mediump vec3 normalMS = normalize(cross(va,vb));
          mediump vec3 normalWS = normalize(mmatrix*normalMS);
          
//           gl_FragColor =  vec4(normalWS.xy,0, 1.0);
          mediump vec4 color = vec4(0,0,0.4,1);
	  //As we are not rotating the view camera direction is always (0,0,1) and with light in (-1,1,1) halfvec is normalize(-1,1,2).
	  mediump vec3 toLightWS = normalize(vec3(-1,1,1));
	  mediump vec3 halfVectorWS = normalize(vec3(-1,1,3));
	  mediump float cosLightAngle = max(dot(normalWS, toLightWS), 0.0);
	  mediump float cosSpecAngle = max(dot(normalWS, halfVectorWS), 0.0);      
	  mediump vec4 surfacecolour = color + cosLightAngle * 0.4 + pow(cosSpecAngle, 50.0);
	  surfacecolour.r = max(surfacecolour.r, colour.b);
// 	  if (colour.b>.1) discard;
          gl_FragColor = surfacecolour;
      }
</script>

<script id="render-vs" type="x-shader/x-vertex">
    uniform sampler2D s_texture;
    attribute highp vec2 posAttr;
    attribute highp vec2 texcoordAttr;
    varying lowp vec2 v_texcoord;
    uniform highp mat4 matrix;
    void main() {
	v_texcoord=texcoordAttr;
	highp vec4 height = texture2D(s_texture, v_texcoord);
	gl_PointSize = 1.0;
	gl_Position = matrix * vec4(posAttr.xy, height.x*.2, 1);
    }
</script>

<script id="wall-fs" type="x-shader/x-fragment">
      void main(void)
      {
	  gl_FragColor = vec4(0,0,1,0);
      }
</script>

<script id="wall-vs" type="x-shader/x-vertex">
      attribute highp vec4 vertex;   
      void main(void)
      {	  
	  gl_Position = vertex;
      }
</script>

<script type="text/javascript">

    function checkError() {
	var glerror = gl.getError()
	if (glerror!=gl.NO_ERROR)
	{
// 	    console.error("GL Error " + WebGLDebugUtils.glEnumToString(glerror));
	    if (glerror==gl.INVALID_ENUM)
	      glerror="GL_INVALID_ENUM";
	    else if (glerror==gl.INVALID_OPERATION)
	      glerror="GL_INVALID_OPERATION";
	    console.error("GL Error " + glerror);
	}
    }
    
    var gl;
    function initGL(canvas) {
        try {
// 	    gl = WebGLDebugUtils.makeDebugContext(canvas.getContext("experimental-webgl"));
            gl = canvas.getContext("experimental-webgl");
        } catch (e) {
        }
        if (gl) {
            return true;
	}else{
	    alert("This page requires WebGL but it cannot be accessed, try upgrading your browser or graphics drivers.");
            return false;
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function getShaderProgram(gl, vertexShader, fragmentShader) {
	var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        return shaderProgram;
    }
    
    var dropShaderProgram;
    var forcecalcShaderProgram;
    var integrateShaderProgram;
    var renderShaderProgram;
    var wallShaderProgram

    function initShaders() {
        var dropFragmentShader = getShader(gl, "drop-fs");
        var dropVertexShader = getShader(gl, "drop-vs");
        var forcecalcFragmentShader = getShader(gl, "forcecalc-fs");
        var forcecalcVertexShader = getShader(gl, "forcecalc-vs");
        var integrateFragmentShader = getShader(gl, "integrate-fs");
        var integrateVertexShader = getShader(gl, "integrate-vs");
        var renderFragmentShader = getShader(gl, "render-fs");
        var renderVertexShader = getShader(gl, "render-vs");
        var wallFragmentShader = getShader(gl, "wall-fs");
        var wallVertexShader = getShader(gl, "wall-vs");

	dropShaderProgram = getShaderProgram(gl, dropFragmentShader, dropVertexShader);
	forcecalcShaderProgram = getShaderProgram(gl, forcecalcFragmentShader, forcecalcVertexShader);
	integrateShaderProgram = getShaderProgram(gl, integrateFragmentShader, integrateVertexShader);
	renderShaderProgram = getShaderProgram(gl, renderFragmentShader, renderVertexShader);
	wallShaderProgram = getShaderProgram(gl, wallFragmentShader, wallVertexShader);

        gl.useProgram(dropShaderProgram);
        dropShaderProgram.vertexAttribute = gl.getAttribLocation(dropShaderProgram, "vertex");
        dropShaderProgram.radiusUniform = gl.getUniformLocation(dropShaderProgram, "radius");
        dropShaderProgram.windowSizeUniform = gl.getUniformLocation(dropShaderProgram, "windowSize");
        dropShaderProgram.channelMaskUniform = gl.getUniformLocation(dropShaderProgram, "channelMask");
                
        gl.useProgram(forcecalcShaderProgram);
        forcecalcShaderProgram.vertexAttribute = gl.getAttribLocation(forcecalcShaderProgram, "vertex");
        forcecalcShaderProgram.texcoordAttribute = gl.getAttribLocation(forcecalcShaderProgram, "texcord");
        forcecalcShaderProgram.windowSizeUniform = gl.getUniformLocation(forcecalcShaderProgram, "windowSize");
        forcecalcShaderProgram.timeUniform = gl.getUniformLocation(forcecalcShaderProgram, "time");
        
        gl.useProgram(integrateShaderProgram);
        integrateShaderProgram.vertexAttribute = gl.getAttribLocation(integrateShaderProgram, "vertex");
        integrateShaderProgram.texcoordAttribute = gl.getAttribLocation(integrateShaderProgram, "texcord");
        
        gl.useProgram(renderShaderProgram);
        renderShaderProgram.vertexAttribute = gl.getAttribLocation(renderShaderProgram, "posAttr");
        renderShaderProgram.texcoordAttribute = gl.getAttribLocation(renderShaderProgram, "texcoordAttr");
        renderShaderProgram.matrixUniform = gl.getUniformLocation(renderShaderProgram, "matrix");     
        renderShaderProgram.mmatrixUniform = gl.getUniformLocation(renderShaderProgram, "mmatrix");
        renderShaderProgram.windowSizeUniform = gl.getUniformLocation(renderShaderProgram, "windowSize");  
        
        gl.useProgram(wallShaderProgram); 
        wallShaderProgram.vertexAttribute = gl.getAttribLocation(wallShaderProgram, "vertex");
        return true;
    }
    
    var waterHeightTX;
    var waterHeightFramebuffer;    
    var waterVelTX;
    var waterVelFramebuffer;
    var WaterBufferSize=512;
    var cvTX;
    
    
    function initFrameBuffers() {
	var ext = gl.getExtension('OES_texture_float');
	if (!ext) {
	  alert("This page requires the 'OES_texture_float' extension, try upgrading your browser or graphics drivers.");
	  return false;
	}
	
	checkError();
	waterHeightTX = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);	
	//Need a replacement for this
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_BORDER);
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_BORDER);
// 	var borderColour = [0.5, 0.0, 0.0, 1.0];
// 	gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_BORDER_COLOR, borderColour);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, WaterBufferSize, WaterBufferSize, 0, gl.RGBA, gl.FLOAT, null);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	waterHeightFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, waterHeightTX, 0);
	gl.viewport(0, 0, WaterBufferSize, WaterBufferSize); 
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	{
	  console.error("Framebuffer Error 1");
	  return false;
	}
	gl.clearColor(0.0, 0.0, 0.0, 1.0);  
        gl.clear(gl.COLOR_BUFFER_BIT);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	checkError();

	waterVelTX = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, waterVelTX);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, WaterBufferSize, WaterBufferSize, 0, gl.RGBA, gl.FLOAT, null);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	
	waterVelFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, waterVelFramebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, waterVelTX, 0);
	gl.viewport(0, 0, WaterBufferSize, WaterBufferSize); 
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	{
	  console.error("Framebuffer Error 2");
	  return false;
	}
	gl.clearColor(0.0, 0.0, 0.0, 1.0);   
        gl.clear(gl.COLOR_BUFFER_BIT);
        
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
	  console.error("Framebuffer Error 3");
	return true;
    }
    
    var meshVertices = [];
    var meshTexCoords = [];
    var meshIndices = [];
    
    function buildMesh()
    {        
	var meshSize = 128;
	for (var i=0; i<meshSize; i++)
	{	
	    for (var j=0; j<meshSize; j++)
	    {
		meshVertices.push(i/meshSize*2-1);
		meshVertices.push(j/meshSize*2-1);
		meshTexCoords.push(i/meshSize*0.96+0.02);//Do not show the edges wich do not move
		meshTexCoords.push(j/meshSize*0.96+0.02);
	    }
	}
	for (var i=0; i<meshSize-1; i++)
	{	
	    for (var j=0; j<meshSize-1; j++)
	    {
		meshIndices.push(j+i*meshSize);
		meshIndices.push(j+1+i*meshSize);
		meshIndices.push(j+(i+1)*meshSize);
		
		meshIndices.push(j+1+i*meshSize);
		meshIndices.push(j+(i+1)*meshSize);
		meshIndices.push(j+1+(i+1)*meshSize);
		
	    }
	}
    }
    
    var VertexPositionBuffer;
    var TexCoordPositionBuffer;
    var VertexPositionBufferR;
    var TexCoordPositionBufferR;
    var IndexBufferR;
    var WallPositionBuffer;
    var BarPositionBuffer;
    var DropPositionBuffer;
    
    function initBuffers() {    
      VertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
      var vertices = [
	  -1, 1,
	  -1, -1,
	  1, -1,

	  1, 1,
	  1, -1,
	  -1, 1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      VertexPositionBuffer.itemSize = 2;
      VertexPositionBuffer.numItems = 6;
// 
      TexCoordPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBuffer);
      var texcords = [
	  0, 1,
	  0, 0,
	  1, 0,

	  1, 1,
	  1, 0,
	  0, 1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcords), gl.STATIC_DRAW);
      TexCoordPositionBuffer.itemSize = 2;
      TexCoordPositionBuffer.numItems = 6;
      
      buildMesh();
      VertexPositionBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBufferR);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshVertices), gl.STATIC_DRAW);
      VertexPositionBufferR.itemSize = 2;
      VertexPositionBufferR.numItems = meshVertices.length/VertexPositionBufferR.itemSize;
      TexCoordPositionBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBufferR);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshTexCoords), gl.STATIC_DRAW);
      TexCoordPositionBufferR.itemSize = 2;
      TexCoordPositionBufferR.numItems = meshTexCoords.length/TexCoordPositionBufferR.itemSize;
      IndexBufferR = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IndexBufferR);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(meshIndices), gl.STATIC_DRAW);
      IndexBufferR.numItems = meshIndices.length;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      
      WallPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, WallPositionBuffer);
//       var wallvertices = [
// 	  -1, 1,
// 	  -1, -1,
// 	  -1, -1,
// 	  1, -1,
// 	  1, -1,
// 	  1, 1,
// 	  1, 1,
// 	  -1, 1,
//       ];
      
      var a = 1 - 1/256;
      var wallvertices = [
	  -a, a,
	  -a, -a,
	  -a, -a,
	  a, -a,
	  a, -a,
	  a, a,
	  a, a,
	  -a, a,
      ];
      
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(wallvertices), gl.STATIC_DRAW);
      WallPositionBuffer.itemSize = 2;
      WallPositionBuffer.numItems = 8;      
      
      BarPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, BarPositionBuffer);
      var barvertices = [
	  -.025, 1,
	  -.025, .05,
	  .025, .05,

	  .025, 1,
	  .025, .05,
	  -.025, 1,
	  
	  -.025, -1,
	  -.025, -0.05,
	  .025, -.05,

	  .025, -1,
	  .025, -0.05,
	  -.025, -1
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(barvertices), gl.STATIC_DRAW);
      BarPositionBuffer.itemSize = 2;
      BarPositionBuffer.numItems = 12;      
      
      DropPositionBuffer = gl.createBuffer();
      return true;
    }
    
    var mvpMatrix;
    var frameNumber=0;
    var newDrops = [];
    var DropSize = 40;
    var render3D = false;
    var rotateAnim = false;
    var rotateProgress = 0;
    var running = true;
    var renderStyle;
    var rotX = -1;
    var rotZ = 3.14/4;
    var zoom=1;

    function drawScene() {
// 
// //         mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
// 
        
	gl.disable(gl.DEPTH_TEST);
	gl.disable(gl.CULL_FACE);
        frameNumber++;      
        //Add a new drop 200 frames in:
        if (frameNumber==200)
        {
	  newDrops = [[-0.5,-0.5]];
	}
	//Add the drops that are in the queue to the framebuffer:
        if (newDrops.length)
        {        
	    checkError();
	    console.log("Preparing to add new drops");
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer);
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);
	    gl.useProgram(dropShaderProgram);
	    gl.uniform2f(dropShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	    gl.uniform1f(dropShaderProgram.radiusUniform, DropSize/2.0);
	    if (frameNumber==1)
		gl.uniform4f(dropShaderProgram.channelMaskUniform, 0,1,0,0);
	    else
		gl.uniform4f(dropShaderProgram.channelMaskUniform, 1,0,0,0);
	    //Add drops
	    var posArray = [];
	    for(var drop =0; drop < newDrops.length; drop++)
	    {        
		  console.log("Adding drop " + drop + " " +newDrops[drop][0] + " " + newDrops[drop][1]);
		  posArray[drop*2+0]=newDrops[drop][0];
		  posArray[drop*2+1]=newDrops[drop][1];
	    }	    
	    console.log(posArray.toString());
	    checkError();
	    gl.enableVertexAttribArray(dropShaderProgram.vertexAttribute);
	    gl.bindBuffer(gl.ARRAY_BUFFER, DropPositionBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posArray), gl.DYNAMIC_DRAW);	    
	    gl.vertexAttribPointer(dropShaderProgram.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
	    checkError();
	    gl.drawArrays(gl.POINTS, 0, newDrops.length);
	    checkError();
	    newDrops = [];
        }
        
        if (running)
        {
	    //Calc water velocity:	
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterVelFramebuffer);  
	    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)
		console.error("Framebuffer Error 4");
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize);
    //         gl.clearColor(1.0, 1.0, 0.0, 1.0);
    //         gl.clear(gl.COLOR_BUFFER_BIT); 
	    gl.useProgram(forcecalcShaderProgram);
	    gl.enableVertexAttribArray(forcecalcShaderProgram.vertexAttribute);
	    gl.enableVertexAttribArray(forcecalcShaderProgram.texcoordAttribute);
	    gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBuffer);
	    gl.vertexAttribPointer(forcecalcShaderProgram.vertexAttribute, VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	    gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBuffer);
	    gl.vertexAttribPointer(forcecalcShaderProgram.texcoordAttribute, TexCoordPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	    gl.uniform2f(forcecalcShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	    gl.enable(gl.BLEND);
	    gl.blendEquation(gl.FUNC_ADD);
	    gl.blendFunc(gl.ONE,gl.ONE);
	    gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);
	    checkError();
	    
	    //Integrate water velocity:	
	    gl.bindTexture(gl.TEXTURE_2D, waterVelTX);
	    gl.bindFramebuffer(gl.FRAMEBUFFER, waterHeightFramebuffer); 
	    gl.viewport(0, 0, WaterBufferSize, WaterBufferSize); 
    //         gl.clearColor(1.0, 0.0, 0.0, 1.0);
    //         gl.clear(gl.COLOR_BUFFER_BIT); 
	    gl.useProgram(integrateShaderProgram);
	    gl.enableVertexAttribArray(integrateShaderProgram.vertexAttribute);
	    gl.enableVertexAttribArray(integrateShaderProgram.texcoordAttribute);
	    gl.enable(gl.BLEND);
	    gl.blendColor(0.995,1,1,1);
	    gl.blendEquation(gl.FUNC_ADD);
	    gl.blendFunc(gl.CONSTANT_COLOR,gl.CONSTANT_COLOR);
	    gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);
	}
	
	//Reset areas that are walls:
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.disable(gl.BLEND);	
        gl.useProgram(wallShaderProgram);
	gl.enableVertexAttribArray(wallShaderProgram.vertexAttribute);	
        gl.bindBuffer(gl.ARRAY_BUFFER, WallPositionBuffer);
        gl.vertexAttribPointer(WallPositionBuffer.vertexAttribute, WallPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.LINES, 0, WallPositionBuffer.numItems);
        gl.bindBuffer(gl.ARRAY_BUFFER, BarPositionBuffer);
        gl.vertexAttribPointer(BarPositionBuffer.vertexAttribute, BarPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLES, 0, BarPositionBuffer.numItems);
	
        
        //Render to screen
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);   
	gl.bindTexture(gl.TEXTURE_2D, waterVelTX); 
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
	gl.bindTexture(gl.TEXTURE_2D, waterHeightTX);
    
	mvpMatrix = mat4.create();
        
	if (render3D && rotateProgress < 1) 
	    rotateProgress+=1.0/60.0;
	else if (!render3D && rotateProgress > 0)
	    rotateProgress-=1.0/60.0;

	var pMatrix = mat4.create();

	var mvMatrix = mat4.create();
	var vMatrix = mat4.create();
	var mMatrix = mat4.create();  	    
	if (rotateProgress>0)
	{	
// 	    var ratio = gl.viewportWidth/gl.viewportHeight;
// 	    mat4.ortho(pMatrix,-ratio,ratio,-1,1,-1,5);
	    mat4.perspective(pMatrix, 1.005, gl.viewportWidth/gl.viewportHeight, 0.1, 5.0);
	    mat4.translate(vMatrix, vMatrix, [0.0, 0.0, -1.82]); 
	    var rotateProgressNL = (Math.sin((rotateProgress+1.5)*Math.PI)+1)/2;
	    mat4.translate(vMatrix, vMatrix, [0,0, -(1.25-zoom)*rotateProgressNL]);
// 	    mat4.translate(vMatrix, vMatrix, [0,.5*rotateProgressNL, 0]);
	    mat4.rotateX(vMatrix, vMatrix, rotX*rotateProgressNL);
	    mat4.rotateZ(mMatrix, mMatrix, rotZ*rotateProgressNL);
// 	    mat4.translate(mvMatrix, mvMatrix, [0,0, .5*rotateProgressNL]);   	
	}
	else
	{
	    var ratio = gl.viewportWidth/gl.viewportHeight;
	    mat4.ortho(pMatrix,-ratio,ratio,-1,1,-1,1);
	}
	
	mat4.multiply(mvMatrix, vMatrix, mMatrix);
	mat4.multiply(mvpMatrix, pMatrix, mvMatrix);
	
	mat4.multiply(mvpMatrix, pMatrix, mvMatrix);
	//We only want the upper left of mMatrix:
	var mMatrix3 = mat3.create();
	mat3.fromMat4(mMatrix3, mMatrix);
	
        gl.useProgram(renderShaderProgram);
        gl.disableVertexAttribArray(2);
        gl.disableVertexAttribArray(3);
	gl.enableVertexAttribArray(renderShaderProgram.vertexAttribute);
	gl.enableVertexAttribArray(renderShaderProgram.texcoordAttribute);
	
        gl.bindBuffer(gl.ARRAY_BUFFER, VertexPositionBufferR);
        gl.vertexAttribPointer(renderShaderProgram.vertexAttribute, VertexPositionBufferR.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, TexCoordPositionBufferR);
        gl.vertexAttribPointer(renderShaderProgram.texcoordAttribute, TexCoordPositionBufferR.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IndexBufferR);
        gl.uniformMatrix4fv(renderShaderProgram.matrixUniform, false, mvpMatrix);
        gl.uniformMatrix3fv(renderShaderProgram.mmatrixUniform, false, mMatrix3);
	gl.uniform2f(renderShaderProgram.windowSizeUniform, WaterBufferSize, WaterBufferSize);
	gl.disable(gl.BLEND);
	gl.enable(gl.DEPTH_TEST);	
	if (renderStyle=="Grid")
	    gl.drawElements(gl.LINES, IndexBufferR.numItems, gl.UNSIGNED_SHORT, 0);//TODO: When rendering grid use an EAB suited for the purpose.
	else if (renderStyle=="Points")
	    gl.drawElements(gl.POINTS, IndexBufferR.numItems, gl.UNSIGNED_SHORT, 0);
	else
	    gl.drawElements(gl.TRIANGLES, IndexBufferR.numItems, gl.UNSIGNED_SHORT, 0);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	
// 	gl.useProgram(integrateShaderProgram);
// 	gl.bindTexture(gl.TEXTURE_2D, cvTX);
// 	gl.enable(gl.BLEND);
// 	gl.blendFunc (gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
// 	gl.drawArrays(gl.TRIANGLES, 0, VertexPositionBuffer.numItems);

//         gl.enableVertexAttribArray(dropShaderProgram.vertexAttribute);
//         mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
//         gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
//         gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
//         setMatrixUniforms();
//         gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
// 
// 
//         mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
//         gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
//         gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
//         setMatrixUniforms();
//         gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
    }
    var stats;
    
    function renderLoop()
    {        
	stats.begin();
	drawScene();
	stats.end();
	requestAnimationFrame( renderLoop );
    }

    
//     function test(canvas1)
//     {    
// 
// 	console.log("test");
//     }
    
    var mouseDragStart = new Object();
    var canvas;
    
    function webGLStart() {
    
// 	mouseDragStart.x=null;
// 	mouseDragStart.y=null;
	stats = new Stats();	
	stats.setMode( 0 ); // 0: fps, 1: ms, 2: mb
	// align top-left
        canvas = document.getElementById("water-canvas");	       

        if (!initGL(canvas))
	    return;
        if (!initShaders())
	    return;
        if (!initFrameBuffers())
	    return;
        if (!initBuffers())
	    return;
	    
	layout();	
	document.body.appendChild( stats.domElement );	
        
        
        canvas.addEventListener('touchstart', function(event) {        
// 	    console.log("touchstart");	
	    if (event.touches.length==2)
	    {
		if (render3D)
		{
		    mouseDragStart.angle = Math.atan2((event.touches[0].clientY-event.touches[1].clientY),(event.touches[0].clientX-event.touches[1].clientX));
		    mouseDragStart.x=(event.touches[0].clientX+event.touches[1].clientX)/2;
		    mouseDragStart.y=(event.touches[0].clientY+event.touches[1].clientY)/2;
		    mouseDragStart.distance=Math.sqrt(Math.pow((event.touches[0].clientX-event.touches[1].clientX),2)+Math.pow((event.touches[0].clientY-event.touches[1].clientY),2));
		    mouseDragStart.rotX=rotX;
		    mouseDragStart.rotZ=rotZ;
		    mouseDragStart.zoom=zoom;
// 		    console.log("mouseDragStart x:" + mouseDragStart.x + " y:" + mouseDragStart.y + " " + mouseDragStart.distance+ " " + mouseDragStart.angle + " " + zoom);
		}
	    }
        });      
        
        canvas.addEventListener('touchmove', function(event) {        
// 	    console.log("touchmove");		    	
	    if (event.touches.length==2 && render3D)
	    {
		var angle = Math.atan2((event.touches[0].clientY-event.touches[1].clientY),(event.touches[0].clientX-event.touches[1].clientX));
// 		if (angle>0.9 && mouseDragStart.lastAngle
// 		mouseDragStart.lastAngle = angle;
		var x=(event.touches[0].clientX+event.touches[1].clientX)/2;
		var y=(event.touches[0].clientY+event.touches[1].clientY)/2;
		var distance=Math.sqrt(Math.pow((event.touches[0].clientX-event.touches[1].clientX),2)+Math.pow((event.touches[0].clientY-event.touches[1].clientY),2));
		zoom=mouseDragStart.zoom*(distance/mouseDragStart.distance);
		zoom=Math.max(zoom, 0.5);
		zoom=Math.min(zoom, 2.0);		
		rotZ=mouseDragStart.rotZ-(angle-mouseDragStart.angle);
		rotX=mouseDragStart.rotX+(y-mouseDragStart.y)/300;
// 		console.log("Touch Dragging " + x + " " + y + " " + angle + " startzoom:" +mouseDragStart.zoom + " zoom:" +zoom+ " " + distance+ " " + mouseDragStart.distance);
	    }
        }); 
        
        canvas.addEventListener('touchend', function(event) {        
// 	    console.log("touchend");		    
	    if (event.touches.length<2)
	    {
		mouseDragStart.x=null;
		mouseDragStart.y=null;
		console.log("Touch Dragging End zoom:" + zoom);
	    }
        }); 
        
        canvas.addEventListener('mousedown', function(event) {
	    var x = event.pageX - canvas.offsetLeft,
		y = event.pageY - canvas.offsetTop;
// 	    console.log("mousedown " + x +" " + y);
	    switch (event.which) {

	    case 1:
    // 	    x = (x / 2.0 + 0.5) * WaterBufferSize;
		if (event.ctrlKey || event.shiftKey)
		{	
		    if (render3D)
		    {
			mouseDragStart.x=x;
			mouseDragStart.y=y;
			mouseDragStart.rotX=rotX;
			mouseDragStart.rotZ=rotZ;
		    }
		}else{
		    x = (x / canvas.clientWidth - 0.5) * 2;
		    y = -(y / canvas.clientHeight - 0.5) * 2;
		    
		    drop = [x,y];
		    var invmat = mat4.create();
		    mat4.invert(invmat, mvpMatrix);
		    var depth=1;
		    var z=-.9;
		    while (depth>.0)
		    {
			z=z+.0005;
			var point = vec4.fromValues(x,y,z,1);
    // 		    console.log("point " + point[0] + " " + point[1]+ " " + point[2]+ " " + point[3]);
			vec4.transformMat4(point, point, invmat);
	// 		console.log("point " + point[0] + " " + point[1]+ " " + point[2]+ " " + point[3]);
    // 		    console.log("point " + point[0]/point[3] + " " + point[1]/point[3]+ " " + point[2]/point[3]);
			depth=point[2]/point[3];
		    }
		    
		    drop = [point[0]/point[3],point[1]/point[3]];
		    newDrops.push(drop);    
		}
            break;            
	    case 3:
		rotateAnim=true;
	    }
        });      
        
        canvas.addEventListener('mousemove', function(event) {     
	    var x = event.pageX - canvas.offsetLeft,
		y = event.pageY - canvas.offsetTop;
// 	    console.log("mousemove " + x +" " + y);
	    if (mouseDragStart.x!=null)
	    {
		console.log("Dragging " + event.which + x + " " + y);
		switch (event.which) {          
		case 1:
		    rotZ=mouseDragStart.rotZ+(x-mouseDragStart.x)/300;
		    rotX=mouseDragStart.rotX+(y-mouseDragStart.y)/300;
		}
	    }
        });
                
        canvas.addEventListener('mouseup', function(event) {     
	    var x = event.pageX - canvas.offsetLeft,
		y = event.pageY - canvas.offsetTop;
// 	    console.log("mouseup " + x +" " + y);
	    if (mouseDragStart.x!=null)
	    {
		console.log("mouseup " + event.which + x + " " + y);
		switch (event.which) {          
		case 1:
		    mouseDragStart.x=null;
		    mouseDragStart.y=null;
		}
	    }
        });
        
        for (var i = 0; i < 20; i++)
        {
	    x = (Math.random() - 0.5) * 2;
	    y = -(Math.random() - 0.5) * 2;
	    drop = [x,y];
	    newDrops.push(drop);
        }

	requestAnimationFrame( renderLoop );
    }	   
        
    function layout() {
	console.log("layout");
	var topBarHeight = 20;
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.left = '8px';
	stats.domElement.style.top = window.innerHeight-58;
	
	canvas.width = window.innerWidth-20;
	canvas.height = window.innerHeight-(topBarHeight+26);	
	canvas.style.position = 'absolute';
	canvas.style.left = '8px';
	canvas.style.top = topBarHeight + 16;
// 	canvas.style.zIndex = '-1';

	gl.viewportWidth = canvas.width;
	gl.viewportHeight = canvas.height;
    
//         var rotateButton = document.getElementById("projectionButton");
// 	rotateButton.style.position = 'absolute';
// 	rotateButton.style.left = '100px';
// 	rotateButton.style.top = '8px';
    }
    
    
    function runButtonPressed() {
//     	var runButton = document.getElementById("runbutton");
	running=!running;
	if (running)
	  runButton.innerHTML="Running";
	else
	  runButton.innerHTML="Paused";	  
    }
    
    function renderButtonPressed(){
	console.log("renderButtonPressed");
//     	var renderbutton = document.getElementById("renderbutton");
	if (renderStyle=="Grid")
	{
	    renderStyle="Points"
	    renderbutton.innerHTML="Points";	  	    
	}
	else if (renderStyle=="Points")
	{
	    renderStyle=null
	    renderbutton.innerHTML="Solid";	  	    
	}
	else
	{
	    renderStyle="Grid"
	    renderbutton.innerHTML="Grid";	  	    
	}
    }
    
    function projectionButtonPressed()
    {
//     	var projectionButton = document.getElementById("projectionButton");    	
	render3D = !render3D;
	if (render3D)
	    projectionButton.innerHTML="3D";
	else
	    projectionButton.innerHTML="2D";
	rotateAnim=true;
    }
</script>
</head>
<body onload="webGLStart();" onresize="layout()">
    <!--<div id="mainbody">
	<h1>Matthew Wellings</h1>
	<p id ="subtitle">Software Developer</p>
	<p>
	Specialising in:<br>
	Qt (For Desktop, Embedded and Server)<br> 
	Android (Java and NDK C++)<br>
	OpenGL (Modern Desktop + ES)<br>
	LAMP software
	</p>

	<h2>Contact</h2>
	<p>
	I can be contacted:<br>
	by email <a href="mailto:website@matthewwellings.com">website@matthewwellings.com</a><br>
	on <a href="https://Google.com/+MatthewWellings">GooglePlus</a><br>
	on <a href="https://www.facebook.com/matt.wellings.90">Facebook</a><br>
	on <a href="skype:openforeveryone">Skype</a>

	<h2>Public Projects</h2>
	<h3>OSS</h3>
	<p>
	<a href="http://wordsearchcreator.org/">Word Search Creator</a><br>
	Other OSS code on <a href="https://github.com/openforeveryone/">my Github page</a>.<br>
	</p>

	<h2>CV</h2>
	For my full CV please contact me.
	on <a href="tel:+441212888633">+44(0)1212888633</a><br>
    </div>-->
    <canvas id="water-canvas" style="border: none;" width="512" height="512"></canvas>    
    <button id = "runButton" type="button" onclick="runButtonPressed();">Running</button>
    <button id = "projectionButton" type="button" onclick="projectionButtonPressed();">2D</button> 
    <button id = "renderbutton" type="button" onclick="renderButtonPressed();">Solid</button>	
</body>
</html>
